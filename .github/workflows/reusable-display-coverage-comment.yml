name: Reusable Display Coverage Comment

on:
  workflow_call:
    inputs:
      minimum-green:
        description: 'Minimum coverage percentage for green status'
        required: false
        default: '99.1'
        type: string
      minimum-orange:
        description: 'Minimum coverage percentage for orange status'
        required: false
        default: '70'
        type: string
    secrets:
      github-token:
        description: 'GitHub token for authentication'
        required: true

jobs:
  display-coverage:
    name: Display Coverage Comment
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    env:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install coverage
        run: |
          python -m pip install --upgrade pip
          pip install coverage

      - name: Install bc for floating point calculations
        run: |
          sudo apt-get update
          sudo apt-get install -y bc

      - name: Download coverage artifacts
        uses: actions/download-artifact@v4
        with:
          name: coverage-report
          path: .

      - name: Download HTML coverage artifacts
        uses: actions/download-artifact@v4
        with:
          name: htmlcov
          path: .

      - name: Verify coverage files exist
        run: |
          echo "Checking for coverage files..."
          ls -la
          if [ -f "coverage.xml" ]; then
            echo "✅ coverage.xml found"
            echo "coverage.xml content (first 10 lines):"
            head -10 coverage.xml
          else
            echo "❌ coverage.xml not found"
            echo "Available files:"
            ls -la
            exit 1
          fi

      - name: Extract coverage percentage
        id: coverage-extract
        run: |
          python -c '''
          import xml.etree.ElementTree as ET
          import os
          
          try:
              if not os.path.exists('coverage.xml'):
                  print(f"ERROR: coverage.xml not found")
                  exit(1)
                  
              tree = ET.parse('coverage.xml')
              root = tree.getroot()
              
              # Use line-rate for coverage calculation
              coverage = None
              if 'line-rate' in root.attrib:
                  coverage = float(root.attrib['line-rate']) * 100
              else:
                  # Search for any element with line-rate
                  for elem in root.iter():
                      if 'line-rate' in elem.attrib:
                          coverage = float(elem.attrib['line-rate']) * 100
                          break
                  else:
                      print(f"ERROR: Could not find line-rate coverage data in coverage.xml")
                      exit(1)
                      
              if coverage is None:
                  print(f"ERROR: Coverage is None")
                  exit(1)
              
              print(f"coverage={coverage:.1f}")
              
              # Check against minimum threshold
              min_coverage = float(os.environ.get('MIN_COVERAGE_THRESHOLD', '${{ inputs.minimum-green }}'))
              if coverage < min_coverage:
                  print(f"ERROR: Coverage {coverage:.1f}% is below minimum threshold {min_coverage}%")
                  exit(1)
              else:
                  print(f"SUCCESS: Coverage {coverage:.1f}% meets minimum threshold {min_coverage}%")
          except Exception as e:
              print(f"ERROR: Error parsing coverage.xml: {e}")
              exit(1)
          '''

      - name: Create coverage comment
        id: comment
        run: |
          COVERAGE=${{ steps.coverage-extract.outputs.coverage }}
          MIN_GREEN=${{ inputs.minimum-green }}
          MIN_ORANGE=${{ inputs.minimum-orange }}
          
          # Check if COVERAGE is empty
          if [ -z "$COVERAGE" ]; then
            echo "❌ Error: COVERAGE is empty from previous step"
            exit 1
          fi
          
          # Determine color based on coverage using awk for floating point comparison
          if awk "BEGIN {exit ($COVERAGE < $MIN_GREEN) ? 0 : 1}"; then
            if awk "BEGIN {exit ($COVERAGE < $MIN_ORANGE) ? 0 : 1}"; then
              COLOR="red"
              EMOJI="❌"
            else
              COLOR="orange"
              EMOJI="⚠️"
            fi
          else
            COLOR="green"
            EMOJI="✅"
          fi
          
          # Create comment content
          COMMENT="## Test Coverage Report $EMOJI
          
          **Coverage:** $COVERAGE%
          **Status:** $COLOR
          
          ### Coverage Details
          - **Minimum Required:** $MIN_GREEN%
          - **Current Coverage:** $COVERAGE%
          - **Status:** $EMOJI $COLOR
          
          ### Coverage Reports
          - [HTML Coverage Report](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts)
          
          ---
          *This comment was automatically generated by the coverage workflow.*"
          
          echo "comment<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMENT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Post coverage comment
        uses: actions/github-script@v7
        with:
          script: |
            const comment = `${{ steps.comment.outputs.comment }}`;
            
            // Only post comments on pull requests
            if (context.eventName === 'pull_request') {
              // Find existing coverage comments and delete them
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number
              });
              
              for (const comment of comments) {
                if (comment.body.includes('Test Coverage Report') && comment.user.login === 'github-actions[bot]') {
                  await github.rest.issues.deleteComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: comment.id
                  });
                }
              }
              
              // Post new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
            } else {
              console.log('Not a pull request, skipping comment posting');
            }
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
